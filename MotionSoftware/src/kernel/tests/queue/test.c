#include <stdio.h>
#include <RF_queue.h>
#include <RF_events.h>
#include <unity.h>
#include <string.h>
#include <float.h>

typedef struct {
	uint32_t val1;
	uint16_t val2;
	bool val3;
} extEventVerBContent;

typedef struct {
	RFEvent baseEvt;
	uint32_t Uint32info;
	bool booleanInfo;
	float floatInfo;
} ExtEventVerA;

typedef struct {
	RFEvent baseEvt;
	extEventVerBContent content;
} ExtEventVerB;

static void run_CheckingJustCreatedQueue(void);
static void run_AddingOneBasicEvent(void);
static void run_AddingTwoBasicEvents(void);
static void run_AddingMaximumBasicEventsForGivenMemoryPool(void);
static void run_AddingMoreThanMaximumAllowedBasicEventsForGivenMemoryPool(void);
static void run_AddingOneExtendedEvent(void);
static void run_AddingMaximumExtendedEvents(void);
static void run_AddingMoreThanMaximumAllowedExtendedEventsForGivenMemoryPool(
		void);
static void run_AddingTwoDifferentExtendedEventsAndOneBasicEvent(void);
static void run_AddOneBasicEventToQueueAndPopItOff(void);
static void run_AddOneBasicEventToQueueThenPopItOffAndClearGarbageAfterConsumed(
		void);
static void run_AddTwoBasicEventsToQueueAndPopThemBothOffByClearingGarbage(void);
static void run_AddMaximumBasicEventsForGivenMemoryPoolAndPopAllOfThemAndClearGarbage(void);
static void run_AddOneBasicEventAndTwoDifferentExtendedEventsAndPopAllOfThemAndClearGarbage(void);

static void clearVariables(void);
static void compareSizeOfInitialisedQueueWithNumber(
		uint8_t expectedSizeInEvents);
static bool isMemoryPoolCleared(void);

#define POOL_SIZE_IN_EVENTS (uint8_t)10
static struct RF_BaseQueue testedQueue;
static RFEvent eventsPool[POOL_SIZE_IN_EVENTS ];

int main() {
	UNITY_BEGIN();
	RUN_TEST(run_CheckingJustCreatedQueue);
	RUN_TEST(run_AddingOneBasicEvent);
	RUN_TEST(run_AddingTwoBasicEvents);
	RUN_TEST(run_AddingMaximumBasicEventsForGivenMemoryPool);
	RUN_TEST(run_AddingMoreThanMaximumAllowedBasicEventsForGivenMemoryPool);
	RUN_TEST(run_AddingOneExtendedEvent);
	RUN_TEST(run_AddingMaximumExtendedEvents);
	RUN_TEST(run_AddingMoreThanMaximumAllowedExtendedEventsForGivenMemoryPool);
	RUN_TEST(run_AddingTwoDifferentExtendedEventsAndOneBasicEvent);
	RUN_TEST(run_AddOneBasicEventToQueueAndPopItOff);
	RUN_TEST(run_AddOneBasicEventToQueueThenPopItOffAndClearGarbageAfterConsumed);
	RUN_TEST(run_AddTwoBasicEventsToQueueAndPopThemBothOffByClearingGarbage);
	RUN_TEST(run_AddMaximumBasicEventsForGivenMemoryPoolAndPopAllOfThemAndClearGarbage);
	RUN_TEST(run_AddOneBasicEventAndTwoDifferentExtendedEventsAndPopAllOfThemAndClearGarbage);
	return UNITY_END();
}

/**
 * TODO
 * Clear all warning generated by compiler
 */
/**
 * TODO
 * Finish this test (the last one)
 */
void run_AddOneBasicEventAndTwoDifferentExtendedEventsAndPopAllOfThemAndClearGarbage(void)
{
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	ExtEventVerA extEvtA = { .baseEvt = { .eventSize = sizeof(ExtEventVerA),
				.pendingConsumers = 1, .signalValue = 20, }, .Uint32info = 50,
				.booleanInfo = true, .floatInfo = 12.5f, };
	ExtEventVerB extEvtB = { .baseEvt = { .eventSize = sizeof(ExtEventVerB),
				.pendingConsumers = 1, .signalValue = 30, }, .content = { .val1 =
				5, .val2 = 10, .val3 = true, } };
	RFEvent basicEvent = { .eventSize = sizeof(RFEvent), .pendingConsumers = 2,
				.signalValue = 150, };
	testedQueue.push(&testedQueue, &extEvtA, extEvtA.baseEvt.eventSize);
	testedQueue.push(&testedQueue, &basicEvent, basicEvent.eventSize);
	testedQueue.push(&testedQueue, &extEvtB, extEvtB.baseEvt.eventSize);
	RFEvent* evt = testedQueue.pop(&testedQueue);
	TEST_ASSERT(evt->eventSize == sizeof(ExtEventVerA));
	TEST_ASSERT(evt->pendingConsumers == 1);
	TEST_ASSERT(evt->signalValue == 20);
	ExtEventVerA* evtA = (ExtEventVerA*)evt;
	TEST_ASSERT(evtA->Uint32info == 50);
	TEST_ASSERT(evtA->booleanInfo);
	TEST_ASSERT(evtA->floatInfo == 12.5f);
	evtA->baseEvt.pendingConsumers--;
	testedQueue.removeGarbage(&testedQueue);
	evt = testedQueue.pop(&testedQueue);
	TEST_ASSERT(evt->eventSize == sizeof(RFEvent));
	TEST_ASSERT(evt->pendingConsumers == 2);
	TEST_ASSERT(evt->signalValue == 150);
	evt->pendingConsumers -= 2;
	testedQueue.removeGarbage(&testedQueue);
	ExtEventVerB* evtB = (ExtEventVerB*)testedQueue.pop(&testedQueue);
	TEST_ASSERT(evtB->baseEvt.eventSize == sizeof(ExtEventVerB));
	TEST_ASSERT(evtB->baseEvt.pendingConsumers == 1);
	TEST_ASSERT(evtB->baseEvt.signalValue == 30);
	TEST_ASSERT(evtB->content.val1 == 5);
	TEST_ASSERT(evtB->content.val2 == 10);
	TEST_ASSERT(evtB->content.val3);
	evtB->baseEvt.pendingConsumers--;
	testedQueue.removeGarbage(&testedQueue);
	TEST_ASSERT(testedQueue.TAIL == NULL);
	TEST_ASSERT(testedQueue.noOfEvents == 0);
}

void run_AddMaximumBasicEventsForGivenMemoryPoolAndPopAllOfThemAndClearGarbage(void)
{
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	RFEvent basicEvents[POOL_SIZE_IN_EVENTS];
	uint8_t evt_i;
	for (evt_i = 0; evt_i < POOL_SIZE_IN_EVENTS; evt_i++)
	{
		basicEvents[evt_i].signalValue = evt_i*10;
		basicEvents[evt_i].pendingConsumers = evt_i;
		basicEvents[evt_i].eventSize = sizeof(RFEvent);
		testedQueue.push(&testedQueue, &basicEvents[evt_i], basicEvents[evt_i].eventSize);
	}
	uint8_t eventExpectedToBeRemovedAlready = 0;
	for (evt_i = 0; evt_i < POOL_SIZE_IN_EVENTS; evt_i++)
	{
		RFEvent * const poppedEvt = testedQueue.pop(&testedQueue);
		uint8_t pendingCons;
		TEST_ASSERT(testedQueue.HEAD->eventSize = basicEvents[evt_i].eventSize);
		TEST_ASSERT(testedQueue.HEAD->pendingConsumers == basicEvents[evt_i].pendingConsumers);
		TEST_ASSERT(testedQueue.HEAD->signalValue == basicEvents[evt_i].signalValue);
		for (pendingCons = poppedEvt->pendingConsumers; pendingCons > 0; pendingCons--)
		{
			poppedEvt->pendingConsumers--;
		}
		TEST_ASSERT(testedQueue.HEAD->pendingConsumers == 0);
		testedQueue.removeGarbage(&testedQueue);
		eventExpectedToBeRemovedAlready++;
		TEST_ASSERT(testedQueue.noOfEvents == (POOL_SIZE_IN_EVENTS-eventExpectedToBeRemovedAlready));
		TEST_ASSERT(testedQueue.spaceLeft == eventExpectedToBeRemovedAlready*sizeof(RFEvent));
	}
	TEST_ASSERT(testedQueue.TAIL == NULL);
	TEST_ASSERT(testedQueue.spaceLeft == testedQueue.totalSize);
}

void run_AddTwoBasicEventsToQueueAndPopThemBothOffByClearingGarbage(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	RFEvent basicEvent1 = { .eventSize = sizeof(RFEvent), .pendingConsumers = 1,
			.signalValue = 150, };
	RFEvent basicEvent2 = { .eventSize = sizeof(RFEvent), .pendingConsumers = 2,
			.signalValue = 300, };
	testedQueue.push(&testedQueue, &basicEvent1, basicEvent1.eventSize);
	testedQueue.push(&testedQueue, &basicEvent2, basicEvent2.eventSize);
	RFEvent * const firstEventPopped = testedQueue.pop(&testedQueue);
	TEST_ASSERT(eventsPool[0].pendingConsumers == 1);
	firstEventPopped->pendingConsumers--;
	TEST_ASSERT(eventsPool[0].pendingConsumers == 0);
	testedQueue.removeGarbage(&testedQueue);
	TEST_ASSERT(memcmp(testedQueue.HEAD, &basicEvent2, sizeof(RFEvent)) == 0);
	RFEvent * const secondEventPopped = testedQueue.pop(&testedQueue);
	secondEventPopped->pendingConsumers--;
	testedQueue.removeGarbage(&testedQueue);
	TEST_ASSERT(testedQueue.HEAD == testedQueue.TAIL);
	TEST_ASSERT(testedQueue.noOfEvents == 1);
	TEST_ASSERT(testedQueue.spaceLeft == testedQueue.totalSize - sizeof(RFEvent));
	TEST_ASSERT(testedQueue.HEAD->eventSize == sizeof(RFEvent));
	TEST_ASSERT(testedQueue.HEAD->pendingConsumers == 1);
	TEST_ASSERT(testedQueue.HEAD->signalValue == 300);
	secondEventPopped->pendingConsumers--;
	testedQueue.removeGarbage(&testedQueue);
	TEST_ASSERT(testedQueue.TAIL == NULL);
	TEST_ASSERT(testedQueue.noOfEvents == 0);
	TEST_ASSERT(testedQueue.spaceLeft == testedQueue.totalSize);
	TEST_ASSERT(isMemoryPoolCleared());
}

void run_AddOneBasicEventToQueueThenPopItOffAndClearGarbageAfterConsumed(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	RFEvent basicEvent = { .eventSize = sizeof(RFEvent), .pendingConsumers = 1,
			.signalValue = 150, };
	testedQueue.push(&testedQueue, &basicEvent, basicEvent.eventSize);
	RFEvent * const eventToBeChecked = testedQueue.pop(&testedQueue);
	eventToBeChecked->pendingConsumers--;
	testedQueue.removeGarbage(&testedQueue);
	TEST_ASSERT(testedQueue.HEAD == &eventsPool[0]);
	TEST_ASSERT(testedQueue.TAIL == NULL);
	TEST_ASSERT(testedQueue.noOfEvents == 0);
	TEST_ASSERT(testedQueue.spaceLeft == POOL_SIZE_IN_EVENTS*sizeof(RFEvent));
	TEST_ASSERT(testedQueue.totalSize == POOL_SIZE_IN_EVENTS*sizeof(RFEvent));
}

void run_AddOneBasicEventToQueueAndPopItOff(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	RFEvent basicEvent = { .eventSize = sizeof(RFEvent), .pendingConsumers = 1,
			.signalValue = 150, };
	testedQueue.push(&testedQueue, &basicEvent, basicEvent.eventSize);
	RFEvent const * const eventToBeChecked = testedQueue.pop(&testedQueue);
	TEST_ASSERT(memcmp(eventToBeChecked, &basicEvent, sizeof(RFEvent)) == 0);
}

void run_AddingTwoDifferentExtendedEventsAndOneBasicEvent(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	ExtEventVerA extEvtA = { .baseEvt = { .eventSize = sizeof(ExtEventVerA),
			.pendingConsumers = 10, .signalValue = 20, }, .Uint32info = 50,
			.booleanInfo = true, .floatInfo = 12.5f, };
	ExtEventVerB extEvtB = { .baseEvt = { .eventSize = sizeof(ExtEventVerB),
			.pendingConsumers = 20, .signalValue = 30, }, .content = { .val1 =
			UINT32_MAX, .val2 = UINT16_MAX, .val3 = true, } };
	RFEvent basicEvent = { .eventSize = sizeof(RFEvent), .pendingConsumers = 30,
			.signalValue = 150, };
	testedQueue.push(&testedQueue, &extEvtA, extEvtA.baseEvt.eventSize);
	testedQueue.push(&testedQueue, &basicEvent, basicEvent.eventSize);
	testedQueue.push(&testedQueue, &extEvtB, extEvtB.baseEvt.eventSize);
	TEST_ASSERT(memcmp(&extEvtA, (&eventsPool[0]), sizeof(ExtEventVerA)) == 0);
	TEST_ASSERT(
			memcmp(&basicEvent,
					((uint64_t )&eventsPool[0] + (uint64_t )sizeof(ExtEventVerA)),
					sizeof(RFEvent)) == 0);
	TEST_ASSERT(
			memcmp(&extEvtB,
					((uint64_t )&eventsPool[0] + (uint64_t )sizeof(ExtEventVerA)
							+ (uint64_t )sizeof(RFEvent)), sizeof(ExtEventVerB))
					== 0);
}

void run_AddingMoreThanMaximumAllowedExtendedEventsForGivenMemoryPool(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	const uint8_t maxEvents = sizeof(RFEvent) * POOL_SIZE_IN_EVENTS
			/ sizeof(ExtEventVerA);
	uint8_t extEv_i;
	for (extEv_i = 0; extEv_i < maxEvents; extEv_i++) {
		ExtEventVerA extEvt = {
				.baseEvt = { .eventSize = sizeof(ExtEventVerA),
						.pendingConsumers = extEv_i * 10, .signalValue = extEv_i
								* 20, }, .Uint32info = extEv_i * 50,
				.booleanInfo = true, .floatInfo = extEv_i * 12.5f, };
		testedQueue.push(&testedQueue, (RFEvent*) &extEvt,
				extEvt.baseEvt.eventSize);
	}
	ExtEventVerA extEvtOverMax = { .baseEvt = { .eventSize =
			sizeof(ExtEventVerA), .pendingConsumers = extEv_i * 10,
			.signalValue = extEv_i * 20, }, .Uint32info = extEv_i * 50,
			.booleanInfo = true, .floatInfo = extEv_i * 12.5f, };
	TEST_ASSERT(
			!testedQueue.push(&testedQueue, (RFEvent* )&extEvtOverMax,
					extEvtOverMax.baseEvt.eventSize));
	TEST_ASSERT(testedQueue.HEAD == eventsPool);
	//TEST_ASSERT((uint64_t)testedQueue.TAIL == ((uint64_t)&eventsPool[0]+(uint64_t)sizeof(ExtEventVerA)*maxEvents));
	TEST_ASSERT(testedQueue.noOfEvents == maxEvents);
	TEST_ASSERT(
			testedQueue.spaceLeft
					== (testedQueue.totalSize - maxEvents * sizeof(ExtEventVerA)));
}

void run_AddingMaximumExtendedEvents(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	const uint8_t maxEvents = sizeof(RFEvent) * POOL_SIZE_IN_EVENTS
			/ sizeof(ExtEventVerA);
	uint8_t extEv_i;
	for (extEv_i = 0; extEv_i < maxEvents; extEv_i++) {
		ExtEventVerA extEvt = {
				.baseEvt = { .eventSize = sizeof(ExtEventVerA),
						.pendingConsumers = extEv_i * 10, .signalValue = extEv_i
								* 20, }, .Uint32info = extEv_i * 50,
				.booleanInfo = true, .floatInfo = extEv_i * 12.5f, };
		testedQueue.push(&testedQueue, (RFEvent*) &extEvt,
				extEvt.baseEvt.eventSize);
	}
	TEST_ASSERT(
			testedQueue.spaceLeft
					== (testedQueue.totalSize - maxEvents * sizeof(ExtEventVerA)));
	TEST_ASSERT(testedQueue.HEAD == &eventsPool[0]);
	TEST_ASSERT(testedQueue.noOfEvents == maxEvents);
	for (extEv_i = 0; extEv_i < maxEvents; extEv_i++) {
		ExtEventVerA evt;
		memcpy(&evt,
				(uint64_t) &eventsPool[0]
						+ (uint64_t) sizeof(ExtEventVerA) * extEv_i,
				sizeof(ExtEventVerA));
		TEST_ASSERT(evt.baseEvt.eventSize == sizeof(ExtEventVerA));
		TEST_ASSERT(evt.baseEvt.pendingConsumers == extEv_i * 10);
		TEST_ASSERT(evt.baseEvt.signalValue == extEv_i * 20);
		TEST_ASSERT(evt.Uint32info == extEv_i * 50);
		TEST_ASSERT(evt.booleanInfo == true);
		TEST_ASSERT(evt.floatInfo == extEv_i * 12.5f);
	}
}

void run_AddingOneExtendedEvent(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	ExtEventVerA evtA = { .baseEvt = { .eventSize = sizeof(ExtEventVerA),
			.pendingConsumers = 2, .signalValue = 100, }, .Uint32info = 1000,
			.booleanInfo = true, .floatInfo = 31.56f, };
	testedQueue.push(&testedQueue, &evtA, ((RFEvent*) &evtA)->eventSize);
	TEST_ASSERT(testedQueue.HEAD == eventsPool);
	TEST_ASSERT(testedQueue.TAIL == eventsPool);
	TEST_ASSERT(testedQueue.noOfEvents == 1);
	TEST_ASSERT(
			testedQueue.spaceLeft
					== (testedQueue.totalSize - sizeof(ExtEventVerA)));
	TEST_ASSERT(
			((ExtEventVerA* )&eventsPool[0])->baseEvt.eventSize
					== sizeof(ExtEventVerA));
	TEST_ASSERT(((ExtEventVerA* )&eventsPool[0])->baseEvt.pendingConsumers == 2);
	TEST_ASSERT(((ExtEventVerA* )&eventsPool[0])->baseEvt.signalValue == 100);
	TEST_ASSERT(((ExtEventVerA* )&eventsPool[0])->Uint32info == 1000);
	TEST_ASSERT(((ExtEventVerA*)&eventsPool[0])->booleanInfo == true);
	TEST_ASSERT(((ExtEventVerA* )&eventsPool[0])->floatInfo == 31.56f);
}

void run_CheckingJustCreatedQueue(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	compareSizeOfInitialisedQueueWithNumber(POOL_SIZE_IN_EVENTS);
	TEST_ASSERT(testedQueue.pop != NULL);
	TEST_ASSERT(testedQueue.push != NULL);
	TEST_ASSERT(testedQueue.HEAD == &eventsPool[0]);
	TEST_ASSERT(testedQueue.TAIL == NULL);
}

void run_AddingOneBasicEvent(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	RFEvent evt = { .eventSize = sizeof(RFEvent), .pendingConsumers = 2,
			.signalValue = 100, };
	testedQueue.push(&testedQueue, &evt, evt.eventSize);
	TEST_ASSERT(testedQueue.HEAD == &eventsPool[0]);
	TEST_ASSERT(testedQueue.TAIL == &eventsPool[0]);
	TEST_ASSERT(testedQueue.noOfEvents == 1);
	TEST_ASSERT(
			testedQueue.spaceLeft == (POOL_SIZE_IN_EVENTS-1)*sizeof(RFEvent));
	TEST_ASSERT(eventsPool[0].eventSize == evt.eventSize);
	TEST_ASSERT(eventsPool[0].pendingConsumers == 2);
	TEST_ASSERT(eventsPool[0].signalValue == 100);
}

void run_AddingTwoBasicEvents(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	RFEvent evt = { .eventSize = sizeof(RFEvent), .pendingConsumers = 2,
			.signalValue = 100, };
	RFEvent secondEvt = { .eventSize = sizeof(RFEvent), .pendingConsumers = 20,
			.signalValue = 250, };
	testedQueue.push(&testedQueue, &evt, evt.eventSize);
	testedQueue.push(&testedQueue, &secondEvt, secondEvt.eventSize);
	TEST_ASSERT(testedQueue.HEAD == &eventsPool[0]);
	TEST_ASSERT(testedQueue.TAIL == &eventsPool[1]);
	TEST_ASSERT(testedQueue.noOfEvents == 2);
	TEST_ASSERT(
			testedQueue.spaceLeft == (POOL_SIZE_IN_EVENTS-2)*sizeof(RFEvent));
	TEST_ASSERT(eventsPool[0].eventSize == evt.eventSize);
	TEST_ASSERT(eventsPool[0].pendingConsumers == 2);
	TEST_ASSERT(eventsPool[0].signalValue == 100);
	TEST_ASSERT(eventsPool[1].eventSize == secondEvt.eventSize);
	TEST_ASSERT(eventsPool[1].pendingConsumers == 20);
	TEST_ASSERT(eventsPool[1].signalValue == 250);
}

void run_AddingMaximumBasicEventsForGivenMemoryPool(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	RFEvent events[POOL_SIZE_IN_EVENTS ];
	uint8_t evt_i;
	for (evt_i = 0; evt_i < POOL_SIZE_IN_EVENTS ; evt_i++) {
		events[evt_i].eventSize = sizeof(RFEvent);
		events[evt_i].pendingConsumers = evt_i * 10;
		events[evt_i].signalValue = evt_i * 25;
		testedQueue.push(&testedQueue, &events[evt_i], events[evt_i].eventSize);
	}

	for (evt_i = 0; evt_i < POOL_SIZE_IN_EVENTS ; evt_i++) {
		TEST_ASSERT(eventsPool[evt_i].eventSize == events[evt_i].eventSize);
		TEST_ASSERT(
				eventsPool[evt_i].pendingConsumers
						== events[evt_i].pendingConsumers);
		TEST_ASSERT(eventsPool[evt_i].signalValue == events[evt_i].signalValue);
	}
	TEST_ASSERT(testedQueue.HEAD == &eventsPool[0]);
	TEST_ASSERT(testedQueue.TAIL == &eventsPool[POOL_SIZE_IN_EVENTS-1]);
	TEST_ASSERT(testedQueue.noOfEvents == POOL_SIZE_IN_EVENTS);
	TEST_ASSERT(testedQueue.spaceLeft == 0);
}

void run_AddingMoreThanMaximumAllowedBasicEventsForGivenMemoryPool(void) {
	clearVariables();
	createEmptyQueue(&testedQueue, eventsPool, sizeof(eventsPool));
	RFEvent events[POOL_SIZE_IN_EVENTS ];
	uint8_t evt_i;
	for (evt_i = 0; evt_i < POOL_SIZE_IN_EVENTS ; evt_i++) {
		events[evt_i].eventSize = sizeof(RFEvent);
		events[evt_i].pendingConsumers = evt_i * 10;
		events[evt_i].signalValue = evt_i * 25;
		TEST_ASSERT(
				testedQueue.push(&testedQueue, &events[evt_i],
						events[evt_i].eventSize));
	}
	RFEvent failedEvent = { .eventSize = sizeof(RFEvent), .pendingConsumers =
			111, .signalValue = 111, };
	TEST_ASSERT(
			!testedQueue.push(&testedQueue, &failedEvent,
					failedEvent.eventSize))
	for (evt_i = 0; evt_i < POOL_SIZE_IN_EVENTS ; evt_i++) {
		TEST_ASSERT(eventsPool[evt_i].eventSize == events[evt_i].eventSize);
		TEST_ASSERT(
				eventsPool[evt_i].pendingConsumers
						== events[evt_i].pendingConsumers);
		TEST_ASSERT(eventsPool[evt_i].signalValue == events[evt_i].signalValue);
	}
	TEST_ASSERT(testedQueue.HEAD == &eventsPool[0]);
	TEST_ASSERT(testedQueue.TAIL == &eventsPool[POOL_SIZE_IN_EVENTS-1]);
	TEST_ASSERT(testedQueue.noOfEvents == POOL_SIZE_IN_EVENTS);
	TEST_ASSERT(testedQueue.spaceLeft == 0);
}

void compareSizeOfInitialisedQueueWithNumber(uint8_t expectedSizeInEvents) {
	TEST_ASSERT_EQUAL_UINT8(expectedSizeInEvents * sizeof(RFEvent),
			(uint8_t )testedQueue.totalSize);
	TEST_ASSERT_EQUAL_UINT8(expectedSizeInEvents * sizeof(RFEvent),
			(uint8_t )testedQueue.spaceLeft);
}

void clearVariables(void)
{
	memset(&testedQueue, 0, sizeof(struct RF_BaseQueue));
	memset(eventsPool, 0, sizeof(RFEvent) * POOL_SIZE_IN_EVENTS);
}

bool isMemoryPoolCleared(void)
{
	static RFEvent eventsPoolEmpty[POOL_SIZE_IN_EVENTS ];
	memset(eventsPoolEmpty, 0, sizeof(RFEvent)*POOL_SIZE_IN_EVENTS);
	return (memcmp(eventsPool, eventsPoolEmpty, sizeof(RFEvent)*POOL_SIZE_IN_EVENTS) == 0);
}
